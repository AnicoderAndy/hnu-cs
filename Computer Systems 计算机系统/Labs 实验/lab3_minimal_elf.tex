\documentclass[a4paper, 11pt]{ctexart}
\usepackage[top=2.54cm, bottom=2.54cm, left=3.18cm, right=3.18cm]{geometry}
\usepackage{titlesec}
\usepackage{hyperref}
\usepackage{setspace}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{minted}
\usepackage{needspace}
\usepackage{amsmath}
\usepackage{lmodern}
\usepackage{xcolor}
\usepackage{colortbl}
\usepackage{array}
\usepackage{longtable}

% stretch line spacing
\setstretch{1.5}
\AtBeginEnvironment{minted}{\singlespacing}
\AtBeginEnvironment{equation}{\singlespacing}

% titlesec settings
\let\oldsection\section
\renewcommand{\section}{\clearpage\oldsection}

% ctex settings
\ctexset{
    section = {
        format = \raggedright\zihao{3}\heiti
    }
}

% fancyhdr settings
\pagestyle{fancy}
\fancyhf{}
\setlength{\headheight}{1.5cm}
\fancyhead[C]{ELF文件与链接实验报告}
\renewcommand{\headrulewidth}{0.5pt}
\fancyfoot[C]{\textbf{\thepage\quad/\quad\pageref{LastPage}}}

% minted settings
\setminted{
    linenos,
    frame = single
}

\definecolor{hlorange}{RGB}{255,230,200}
\definecolor{hlgreen}{RGB}{210,250,200}
\definecolor{hlblue}{RGB}{200,230,255}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Begin Document
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
\sloppy
%%%%% Cover Page %%%%%
\begin{titlepage}
    \begin{center}
        \vspace*{5cm}
        \yahei\zihao{1}《计算机系统》\\ \vspace{50pt}ELF文件与链接实验报告
        \vfill
        \zihao{3}
        \begin{tabular}{ll}
            班级: & GitHub\\
            学号: & 78268851\\
            姓名: & AnicoderAndy\\
        \end{tabular}
    \end{center}
\end{titlepage}
\setcounter{page}{2}

%%%%% Table of Contents %%%%%
\renewcommand{\contentsname}{\centering 目录}
\tableofcontents

\section{实验项目}
\setcounter{subsection}{0}
\subsection{项目名称}
手搓最小可执行文件——ELF文件与链接实验

\subsection{实验目的}
\begin{itemize}
    \item 了解ELF文件格式的基本结构，掌握ELF文件的基本组成部分。
    \item 尝试分析链接过程的各个环节，探寻编译过程中文件大小膨胀的原因。
\end{itemize}

\subsection{实验目标}
对于下面的源代码文件\texttt{andy.c}：

\begin{minted}{c}
int main() { return 7; }
\end{minted}

本实验要分析编译和连接过程中增加了什么内容导致可执行文件的大小产生膨胀，并尽可能获得更小的可执行文件。

实验在64位Ubuntu 22.04 LTS上进行，使用编译器、汇编器、链接器模拟32位环境。使用gcc~11.4.0，nasm~2.15.05，ld~2.38作为工具链。Shell环境为zsh~5.8.1。

\section{实验任务}
\subsection{优化编译指令}
使用\texttt{gcc -m32 andy.c -o andy}命令编译，得到\texttt{andy}可执行文件。使用bash命令\texttt{ls -l andy}查看文件大小，得到的结果是此文件大小为14908B。

从源代码层面来看，该源代码在 C 层面已经无法再精简，因为根据C标准要求，每个程序必须含有\texttt{main}函数作为入口，且必须显示返回非零状态码，此源代码无法再精简。

尝试使用gcc提供的\texttt{-Os}选项进行优化，\texttt{-s}选项剔除符号表和重定位信息编译，命令为：\texttt{gcc andy.c -m32 -Os -s -o step1}。使用bash命令\texttt{ls -l step1}查看文件大小，得到的结果是此文件大小为13656B，可以发现文件大小减小并不明显。

\subsection{编写汇编代码}
\label{sec:asm}

为了尝试在汇编层次优化代码，本节熟悉nasm的使用方法。新建\texttt{test.asm}文件，编写汇编代码：

\begin{minted}{nasm}
bits 32
global main
section .text

main:
    mov eax, 5
    mov ebx, 10
    add eax, ebx
    ret
\end{minted}

通过\texttt{nasm -f elf32 test.asm ; gcc -m32 -Wall -s test.o}命令汇编并链接代码。运行得到的程序发现其返回了错误码15。

\subsection{调整汇编代码}
虽然C源码逻辑很简单，但默认的动态链接过程会引入一整套运行时启动与结束框架，其中包括启动代码（链接\texttt{crt1.o}等文件，包含\texttt{\_start}等调用）、动态链接器（链接\texttt{ld-linux.so}等文件）、符号重定位。

为了实现最简单的返回状态码的功能，没有必要调用外部的库函数，所以首先尝试使用\texttt{-nostdlib}来取消连接标准库和启动代码：

\begin{minted}[breaklines=true,linenos=false]{bash}
prompt> gcc -m32 -Wall -s -nostdlib test.o
/usr/bin/ld: warning: cannot find entry symbol _start; defaulting to 0000000000001000
prompt> ./a.out
[1]    10410 segmentation fault (core dumped)  ./a.out
\end{minted}

执行命令时gcc提出找不到\texttt{\_start}的警告，运行时因为没有\texttt{\_start}而导致段错误。所以接下来尝试直接把逻辑写入\texttt{\_start}：

\begin{minted}{nasm}
bits 32
global _start
section .text

_start:
    mov eax, 7
    ret
\end{minted}

再次执行前面的汇编、链接指令。尽管这次没有任何警告，但执行时仍然会遇到段错误，原因是\texttt{\_start}并不是函数，而是程序的入口，不应该有返回值。这里强制执行\textrm{ret}命令，调试时发现会尝试返回到\texttt{0x0001}的位置，由于权限问题而触发段错误。

对汇编代码进行修改，我们应该使用\texttt{int 0x80}唤醒内核，让操作系统结束进程。进行系统调用时，\texttt{eax}寄存器中需要放入系统调用号（这里放入1表示结束进程），\texttt{ebx}寄存器中需要放入系统调用参数（这里放入7表示返回值）：

\begin{minted}{nasm}
bits 32
global _start
section .text

_start:
    mov eax, 1
    mov ebx, 7
    int 0x80
\end{minted}

通过\texttt{readelf -l a.out}可以发现该文件还包含了很多链接相关的内容：

\begin{minted}[linenos=false]{bash}
 Section to Segment mapping:
  Segment Sections...
   00     
   01     .interp 
   02     .interp .note.gnu.build-id .gnu.hash .dynsym .dynstr 
   03     .text 
   04     .eh_frame 
   05     .dynamic 
   06     .dynamic 
   07     .note.gnu.build-id 
   08     .dynamic
\end{minted}

所以我们采用\texttt{ld -m elf\_i386 test.o -o step3}命令来链接。得到的文件大小为4472B。

为了后续操作能顺利进行，我们修改\texttt{test.asm}文件以缩减汇编代码：

\begin{minted}{nasm}
bits 32
global _start
section .text

_start:
    xor eax, eax
    inc eax
    mov bl, 7
    int 0x80
\end{minted}

经过汇编、链接得到的\texttt{step3}文件大小为4468B。

\subsection{编写ELF文件}
\label{sec:elf}

通过\texttt{readelf -h step3}检查ELF头：

\begin{minted}[linenos=false]{text}
ELF Header:
  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF32
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           Intel 80386
  Version:                           0x1
  Entry point address:               0x8049000
  Start of program headers:          52 (bytes into file)
  Start of section headers:          4268 (bytes into file)
  Flags:                             0x0
  Size of this header:               52 (bytes)
  Size of program headers:           32 (bytes)
  Number of program headers:         2
  Size of section headers:           40 (bytes)
  Number of section headers:         5
  Section header string table index: 4
\end{minted}

其中包括了ELF格式（ELF32）、编码方式（二进制补码）、操作系统（UNIX）、文件类型（可执行文件）、机器类型（Intel 80386）、入口地址（0x8049000）、程序头表偏移（52字节）、节头表偏移（4268字节）等信息。

通过\texttt{readelf -l step3}检查程序头：

\begin{minted}[linenos=false]{text}
Elf file type is EXEC (Executable file)
Entry point 0x8049000
There are 2 program headers, starting at offset 52

Program Headers:
  Type     Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
  LOAD     0x000000 0x08048000 0x08048000 0x00074 0x00074 R   0x1000
  LOAD     0x001000 0x08049000 0x08049000 0x00007 0x00007 R E 0x1000

 Section to Segment mapping:
  Segment Sections...
   00     
   01     .text
\end{minted}

其中定义了如何将文件加载到内存并执行。它告诉操作系统如何将ELF文件的各个Segment映射到内存，还标记了各个段的控制权限。本ELF文件中程序头表只包含了两个类型为LOAD的段，并且给出了它们在文件中的偏移量、虚拟地址、物理地址（本质上也是虚拟地址）、文件大小、内存大小、控制权限和对齐方式。

通过\texttt{readelf -S step3}可以发现可执行文件的节与预期相类似：

\begin{minted}[linenos=false]{text}
There are 5 section headers, starting at offset 0x10ac:

Section Headers:
  [Nr] Name       Type      Addr     Off    Size   ES Flg Lk Inf Al
  [ 0]            NULL      00000000 000000 000000 00      0   0  0
  [ 1] .text      PROGBITS  08049000 001000 000007 00  AX  0   0 16
  [ 2] .symtab    SYMTAB    00000000 001008 000060 10      3   2  4
  [ 3] .strtab    STRTAB    00000000 001068 000022 00      0   0  1
  [ 4] .shstrtab  STRTAB    00000000 00108a 000021 00      0   0  1
\end{minted}

\texttt{.rodata}、\texttt{.data}、\texttt{.bss}分别存放只读变量、已初始化全局变量和静态变量、未初始化全局变量和静态变量。由于本实验没有使用这些变量，所以它们并不存在，也并不必需。对于一个可执行文件来说，其必要的部分是ELF header、Program header以及\texttt{.text}节，其他部分（如节头表、符号表、字符串表、重定位表、调试段等）主要服务于链接器、调试器、分析工具等其他功能。

了解以上信息后，即可开始编写ELF文件\texttt{simple\_elf.asm}：

\begin{minted}{nasm}
BITS 32
            org 0x08048000
ehdr:                       ; Elf32_Ehdr
            db 0x7F, "ELF", 1, 1, 1, 0 ; e_ident
            times 8 db 0
            dw 2            ; e_type
            dw 3            ; e_machine
            dd 1            ; e_version
            dd _start       ; e_entry
            dd phdr - $$    ; e_phoff
            dd 0            ; e_shoff
            dd 0            ; e_flags
            dw ehdrsize     ; e_ehsize
            dw phdrsize     ; e_phentsize
            dw 1            ; e_phnum
            dw 0            ; e_shentsize
            dw 0            ; e_shnum
            dw 0            ; e_shstrndx
ehdrsize    equ $ - ehdr
phdr:                       ; Elf32_Phdr
            dd 1            ; p_type
            dd 0            ; p_offset
            dd $$           ; p_vaddr
            dd $$           ; p_paddr
            dd filesize     ; p_filesz
            dd filesize     ; p_memsz
            dd 5            ; p_flags
            dd 0x1000       ; p_align
phdrsize    equ $ - phdr
_start:
            xor eax, eax
            inc eax
            mov bl, 7
            int 0x80
filesize    equ $ - $$
\end{minted}

通过\texttt{nasm -f bin simple\_elf.asm -o step4}汇编，通过\texttt{chmod u+x step4}赋予文件可执行权限。执行\texttt{./step4}，正常返回7。通过\texttt{ls -l step4}得到的文件大小为91B。

\subsection{优化ELF文件}

通过hexdump命令查看\texttt{step4}文件的十六进制内容如表~\ref{tab:step4_hex}\ 所示。

\begingroup
\begin{table}[htbp]
    \centering
    \setlength{\tabcolsep}{4pt}
    \begin{ttfamily}
    \begin{tabular}{l|*{16}{>{\columncolor{white}}c}}
    \textbf{Addr} &
    7f & 45 & 4c & 46 & 01 & 01 & 01 & 00 &
    00 & \cellcolor{hlorange}00 & \cellcolor{hlorange}00 & \cellcolor{hlorange}00 & \cellcolor{hlorange}00 & \cellcolor{hlorange}00 & \cellcolor{hlorange}00 & \cellcolor{hlorange}00 \\
    00000010 &
    02 & 00 & 03 & 00 & 01 & 00 & 00 & 00 &
    54 & 80 & 04 & 08 & 34 & 00 & 00 & 00 \\
    00000020 &
    00 & 00 & 00 & 00 & 00 & 00 & 00 & 00 &
    34 & 00 & 20 & 00 & \cellcolor{hlblue}01 & \cellcolor{hlblue}00 & \cellcolor{hlblue}00 & \cellcolor{hlblue}00 \\
    00000030 &
    \cellcolor{hlblue}00 & \cellcolor{hlblue}00 & \cellcolor{hlblue}00 & \cellcolor{hlblue}00 &
    \cellcolor{hlgreen}01 & \cellcolor{hlgreen}00 & \cellcolor{hlgreen}00 & \cellcolor{hlgreen}00 &
    \cellcolor{hlgreen}00 & \cellcolor{hlgreen}00 & \cellcolor{hlgreen}00 & \cellcolor{hlgreen}00 &
    00 & 80 & 04 & 08 \\
    00000040 &
    00 & 80 & 04 & 08 & 5b & 00 & 00 & 00 &
    5b & 00 & 00 & 00 & 05 & 00 & 00 & 00 \\
    00000050 &
    00 & 10 & 00 & 00 & 31 & c0 & 40 & b3 &
    07 & cd & 80 & & & & & \\
    \end{tabular}
    \end{ttfamily}
    \caption{\texttt{step4}文件的十六进制内容}
    \label{tab:step4_hex}
\end{table}
\endgroup

不难注意到，ELF文件头部的\texttt{e\_ident}部分末尾有很多空置的0（橙色部分），我们程序主体部分的代码一共只有7字节，可以填充在这一部分。

同样不难注意到，ELF头部的末8字节（蓝色部分）与程序头的前8字节（绿色部分）是完全一致的，所以可以将程序头的标签直接放在ELF头部的尾部对应位置。

基于此，修改前面的\texttt{simple\_elf.asm}文件，重命名为\texttt{tiny.asm}：

\begin{minted}{nasm}
BITS 32
            org 0x08048000
ehdr:                   ; Elf32_Ehdr
            db 0x7F, "ELF", 1, 1, 1, 0, 0 ; e_ident
_start:
            xor eax, eax
            inc eax
            mov bl, 7
            int 0x80
            dw 2            ; e_type
            dw 3            ; e_machine
            dd 1            ; e_version
            dd _start       ; e_entry
            dd phdr - $$    ; e_phoff
            dd 0            ; e_shoff
            dd 0            ; e_flags
            dw ehdrsize     ; e_ehsize
            dw phdrsize     ; e_phentsize
phdr:
            dw 1            ; e_phnum, p_type low_8
            dw 0            ; e_shentsize, p_type high_8
            dw 0            ; e_shnum, p_offset low_8
            dw 0            ; e_shstrndx, p_offset high_8
ehdrsize    equ $ - ehdr
            dd $$           ; p_vaddr
            dd $$           ; p_paddr
            dd filesize     ; p_filesz
            dd filesize     ; p_memsz
            dd 5            ; p_flags
            dd 0x1000       ; p_align
phdrsize    equ $ - phdr
filesize    equ $ - $$
\end{minted}

使用\texttt{nasm -f bin tiny.asm -o step5}汇编后，使用\texttt{chmod u+x step5}赋予文件可执行权限。执行\texttt{./step5}，正常返回7。通过\texttt{ls -l step5}得到的文件大小为76B。

\subsection{最终优化步骤}

分析ELF Header各部分的作用见表~\ref{tab:elf_header}\ 所示。

\begin{longtable}{|c|c|c|c|}
\hline
\textbf{偏移} & \textbf{字段名} & \textbf{大小} & \textbf{作用说明} \\
\hline
\endfirsthead

\hline
\textbf{偏移} & \textbf{字段名} & \textbf{大小} & \textbf{作用说明} \\
\hline
\endhead

0x00 & e\_ident & 16 & 魔数、ELF类、字节序、版本等识别信息 \\
\hline
0x10 & e\_type & 2 & 文件类型 \\
\hline
0x12 & e\_machine & 2 & 目标平台架构类型（如 x86 是 3） \\
\hline
0x14 & e\_version & 4 & ELF 文件版本（目前固定为 1） \\
\hline
0x18 & e\_entry & 4 & 程序的入口点虚拟地址 \\
\hline
0x1C & e\_phoff & 4 & 程序头表（Program Header Table）的文件偏移 \\
\hline
0x20 & e\_shoff & 4 & 段头表（Section Header Table）的文件偏移 \\
\hline
0x24 & e\_flags & 4 & 处理器特定的标志位（如 ARM 有相关定义） \\
\hline
0x28 & e\_ehsize & 2 & ELF 文件头的总大小，通常为 52 字节 \\
\hline
0x2A & e\_phentsize & 2 & 程序头表中每个表项的大小 \\
\hline
0x2C & e\_phnum & 2 & 程序头表中的表项数量 \\
\hline
0x2E & e\_shentsize & 2 & 段头表中每个表项的大小 \\
\hline
0x30 & e\_shnum & 2 & 段头表中的表项数量 \\
\hline
0x32 & e\_shstrndx & 2 & 段名称字符串表在段表中的索引 \\
\hline
\caption{32位 ELF Header 各字段说明表}\label{tab:elf_header}
\end{longtable}
\vspace{-\baselineskip}

不难发现，ELF Header的大部分必要字段都在前半部分，后半部分几乎都可以自由修改，于是我们试图让程序头尽可能占据ELF头的后半部分，将此文件命名为\texttt{ultimate.asm}：

\begin{minted}{nasm}
BITS 32
            org 0x00200000
ehdr:                       ; Elf32_Ehdr
            db 0x7F, "ELF", 1, 1, 1, 0, 0 ; e_ident
_start:
            xor eax, eax
            inc eax
            mov bl, 7
            int 0x80
            dw 2            ; e_type
            dw 3            ; e_machine
            dd 1            ; e_version
            dd _start       ; e_entry
            dd phdr - $$    ; e_phoff
phdr:
            dd 1            ; e_shoff, ptype
            dd 0            ; e_flags, p_offset
            dd $$           ; e_ehsize, p_vaddr
                            ; e_phentsize
            dw 1            ; e_phnum, p_paddr low_8
            dw 0            ; e_shentsize, p_paddr high_8
            dd filesize     ; e_shnum, p_filesz
                            ; e_shstrndx
            dd filesize     ; p_memsz
            dd 5            ; p_flags
            dd 0x1000       ; p_align
filesize    equ $ - $$
\end{minted}

注意到Program Header占据了ELF Header中两个非常重要的字段：\texttt{e\_phentsize}和\texttt{e\_phnum}，它们分别表示每个程序头表项的大小和程序头表项的数量。我们需要调整程序加载位置使得\texttt{e\_phentsize}恰与\texttt{phdr}地址高8位相同。将加载地址高8位定位0x0020（十进制下的32），低8位置零可以满足这一约束。

下面考虑处理Program Header的字段。注意到\texttt{p\_memsz}至少要等于\texttt{p\_filesz}，但如果它更大不会有影响。基于这个事实可以重新组织ELF文件（本文件命名为\texttt{nightmare.asm}）：

\begin{minted}{nasm}
BITS 32
            org 0x00010000
            db 0x7F, "ELF"  ; e_ident
            dd 1                            ; p_type
            dd 0                            ; p_offset
            dd $$                           ; p_vaddr
            dw 2            ; e_type        ; p_paddr
            dw 3            ; e_machine
            dd _start       ; e_version     ; p_filesz
            dd _start       ; e_entry       ; p_memsz
            dd 4            ; e_phoff       ; p_flags
_start:
            mov bl, 7       ; e_shoff       ; p_align
            xor eax, eax
            inc eax         ; e_flags
            int 0x80
            db 0
            dw 0x34         ; e_ehsize
            dw 0x20         ; e_phentsize
            dw 1            ; e_phnum
            dw 0            ; e_shentsize
            dw 0            ; e_shnum
            dw 0            ; e_shstrndx
filesize    equ $ - $$
\end{minted}

目前我们将程序主体放在了ELF Header的\texttt{e\_shoff}表项和\texttt{e\_flags}表项之间。我们将\texttt{e\_phoff}设置为了4，使得程序头也和ELF Header的较前位置重叠。检查当前程序头的表项，注意到\texttt{p\_filesz}和\texttt{p\_memsz}都指向了程序主体的起始位置，我们可以将加载地址设置小一些来减小占用内存（虚拟化内存下内存一般由操作系统动态分配，不会直接分配全部\texttt{e\_memsz}大小的内存，所以其实这一指标并不重要）。值得注意的是\texttt{p\_flags}被设置为了4，表示内存可读而不可写，操作系统要求这种情况下\texttt{p\_memsz}必须小于等于\texttt{p\_filesz}，我们将两个指标都设置为大于文件实际大小的值就不会引发异常。

使用\texttt{nasm}汇编为\texttt{step6}文件后通过\texttt{readelf -h -l step6}查看头文件发现很多信息已经不再正确（例如节头位置、版本信息等），但它们并不影响程序正常运行。我们又注意到文件的末7字节都是0，Linux系统在尝试加载不符合要求的ELF文件时空缺位都会用0补足，所以这些0也可通过\texttt{truncate -s -7 step6}删除，此时文件大小为45B。赋予\texttt{step6}可执行权限并运行，程序正常返回7。使用\texttt{readelf -h step6}出错，因为删除末尾0后文件不再是符合规范的ELF文件。

\section{总结}
\subsection{实验中出现的问题}
\begin{itemize}
        \item \textbf{readelf与gdb中Entry Point不一致。}  
        在\ \ref{sec:asm}\ 节中完成汇编链接后，使用\texttt{readelf -h}查看ELF入口点为\texttt{0x1000}，但在gdb中\texttt{start}断点位置却在\texttt{0x56556000}附近。查询资料发现这是因为\texttt{start}并非程序的实际入口\texttt{\_start}，而是相对加载位置的偏移量，gdb的启动断点并没有错误。
    
        \item \textbf{手写ELF后nasm无法汇编。}  
        在\ \ref{sec:elf}\ 节中尝试使用\texttt{nasm -f elf32}编译手写ELF结构的汇编代码后报错。问题出在nasm默认生成的是中间目标文件，而精简ELF使用\texttt{-f bin}生成扁平二进制格式。
\end{itemize}

\subsection{心得体会}
经过本次“手搓最小ELF可执行文件”实验，我首先深入理解了ELF文件格式：从一开始默认使用GCC编译出动辄十几KB的可执行文件，到手工用汇编构造完整的ELF头和程序头，去除section headers、符号表、重定位表等不必要的内容，我切身感受到了ELF文件各字段的含义与作用；我也通过readelf、hexdump等工具对比分析，验证了各段在文件与内存中的映射关系，真正理解了虚拟基址与文件偏移等链接相关知识。其次，我还了解到了极限压缩可执行文件的多种手段：从调用gcc的\texttt{-Os}、\texttt{-s}等选项，到使用\texttt{ld}链接器的\texttt{-nostdlib}，到手写ELF文件并且通过\texttt{truncate}命令删除多余字节，最终将可执行文件压缩到45B。
\end{document}